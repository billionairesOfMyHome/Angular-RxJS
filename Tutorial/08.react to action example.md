# react to selection data stream



product.service.ts：先指定一个硬编码的 id

```ts

  selectedProduct$ = this.productWithCategory$
    .pipe(
     map((products) => products.find(product => product.id === 5)),
     tap(product => console.log('selectedProduct:', product)
     )
    )

```

product-detail.component.ts

```ts
  
changeDetection: ChangeDetectionStrategy.OnPush

  product$ = this.productService.selectedProduct$
    .pipe(
      catchError(err => {
        this.errorMessage = err;
        return EMPTY;
      })
    );
    
```

product-detail.component.html

```ts

*ngIf="product$ | async as product">

```



# react to selection action stream



因为 product-list-alt.component.ts 和 product-detail.component.ts 组件都会对 selection action 作出反应，因此将 action stream 定义在 service 中。

product.service.ts

```ts

private productSelectedSubject$ = new BehaviorSubject<number>(1);

private productSelectedAction$ = this.productSelectedSubject$.asObservable();

selectedProduct$ = combineLatest([
    this.productsWithCategory$, 
    this.productSelectedAction$])
   .pipe(
    map(([products,selectedProductId]) => 
      products.find(product => product.id === selectedProductId)),
    tap(product => console.log('selectedProduct:', product)
    )
   )

selectedProductChanged(selectedProductId: number){
    this.productSelectedSubject$.next(selectedProductId);
}

```

product-list-alt.component.ts

```ts
  
changeDetection: ChangeDetectionStrategy.OnPush

selectedProduct$ = this.productService.selectedProduct$;

onSelected(productId: number): void {
    this.productService.selectedProductChanged(productId)
}
    
```

product-list-alt.component.html

```html

<button type="button"
        class="list-group-item"
        *ngFor="let product of products"
        [ngClass]="{ active: product?.id === (selectedProduct$ | async)?.id}"
        (click)="onSelected(product.id)">
        {{ product.productName }} ({{ product.category }})
</button>

```



# react to an error



由于在 component 上面定义了组件变更检测方式为 OnPush，最小化了变更检测周期以提高性能，但只有三种情况可以触发变更检测以及更新模板：

1. input 属性改变
2. 子组件事件触发
3. observable 对象使用 async pipe 绑定在模板中，且该 observable 对象  emit 了 item

因此 error message 必须定义成 observable stream，才能向用户显示错误消息。这里可以将 errorMessage 定义成 action stream，既可以用 next() method emit 值，又可以在模板中订阅

product-list-alt.component.ts

```ts
  
  private errorMessageSubject$ = new Subject<string>();
  errorMessage$ = this.errorMessageSubject$.asObservable();

  products$ = this.productService.productsWithCategory$
    .pipe(
      catchError(err=>{
        this.errorMessageSubject$.next(err);
        return EMPTY;
      })
    )
    
```

product-list-alt.component.html

```html

<div class="alert alert-danger"
     *ngIf="(errorMessage$ | async) as errorMessage">
  {{ errorMessage }}
</div>

```





# merge

## 是什么

filter 是可以在 pipe 中使用的 transformation operator

```typescript
a$.pipe(
    filter(item => item === 1)
)

```

## 机制

过滤所有的 input observable items 满足给定的 function 时，才会 emit 出去

<img src="C:/Learning/Angular/Angular-RxJS/Tutorial/imgs/combineLatest1.png" style="zoom:50%;" />

## 举例

## 什么时候完成

## 适用场景

## 不适用场景

## 总结



# scan

## 是什么

filter 是可以在 pipe 中使用的 transformation operator

```typescript
a$.pipe(
    filter(item => item === 1)
)

```

## 机制

过滤所有的 input observable items 满足给定的 function 时，才会 emit 出去

<img src="C:/Learning/Angular/Angular-RxJS/Tutorial/imgs/combineLatest1.png" style="zoom:50%;" />

## 举例

## 什么时候完成

## 适用场景

## 不适用场景

## 总结



# 模板

## 是什么

filter 是可以在 pipe 中使用的 transformation operator

```typescript
a$.pipe(
    filter(item => item === 1)
)

```

## 机制

过滤所有的 input observable items 满足给定的 function 时，才会 emit 出去

<img src="C:/Learning/Angular/Angular-RxJS/Tutorial/imgs/combineLatest1.png" style="zoom:50%;" />

## 举例

## 什么时候完成

## 适用场景

## 不适用场景

## 总结