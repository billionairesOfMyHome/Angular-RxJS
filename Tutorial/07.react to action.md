# reactive development



响应式开发：1.声明性编程范式（async pipe）  2.考虑数据流  3.传播变化

<img src="imgs\reactive_development.png" style="zoom:60%;" />



# filter

## 是什么

filter 是可以在 pipe 中使用的 transformation operator

```typescript

a$.pipe(
    filter(item => item === 1)
)

```

## 机制

过滤所有的 input observable items 满足给定的 function 时，才会 emit 出去

<img src="imgs\filter_pipeable _operator.png" style="zoom:50%;" />

## 什么时候完成

filter 在 input observable complete 时 complete

## 适用场景

只 emit 符合特定条件的 item 的场景

## 总结

<img src="imgs\filter_总结.png" style="zoom:50%;" />



# Data stream VS Action stream

## HTTP GET stream

当调用 HTTP Get 时，observable emit 一个 item 后立即 complete，然后这个 data stream 就死了，不会再重新触发

<img src="imgs\data_stream.png" style="zoom:50%;" />

## action Stream

当定义 action 的 observable 时，action 每次触发，observable 都会 emit 值，action stream 会一直活着，直到 observable 被终止

<img src="imgs\action_stream.png" style="zoom:50%;" />

## combine data stream and action Stream

```typescript

combineLatest( [ data$, action$ ] )
  .pipe( map( ([datas, action]) => {
    //...
} ))

```

combineLatest 在 data$ 和 action$ 各 emit 一个值后，action$ 再次 emit 值时，

# filter

## 是什么

filter 是可以在 pipe 中使用的 transformation operator

```typescript
a$.pipe(
    filter(item => item === 1)
)

```

## 机制

过滤所有的 input observable items 满足给定的 function 时，才会 emit 出去

<img src="imgs\combineLatest1.png" style="zoom:50%;" />

## 举例

## 什么时候完成

## 适用场景

## 不适用场景

## 总结
